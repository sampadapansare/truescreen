<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Interview</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #f5f6fa;
        }
        .card {
            background-color: white;
            padding: 30px;
            margin-top: 50px;
            border-radius: 10px;
            box-shadow: 0px 0px 20px rgba(0,0,0,0.1);
        }
        .card-title {
            color: #2f3640;
        }
        .video-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        video {
            border: 2px solid #2f3640;
            border-radius: 10px;
            width: 100%;
            height: 300px;
            background-color: #000;
        }
        .controls {
            text-align: center;
            margin-top: 20px;
        }
        button {
            background-color: #0984e3;
            color: white;
            padding: 12px 25px;
            font-size: 16px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            margin: 0 10px;
        }
        button:hover {
            background-color: #74b9ff;
        }
        #status {
            margin-top: 15px;
            color: #666;
            font-style: italic;
        }
        .debug {
            margin-top: 20px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h2 class="card-title">Live Interview - Room: {{ meeting_id }}</h2>
            <div class="video-container">
                <div>
                    <h5>You</h5>
                    <video id="localVideo" autoplay muted playsinline></video>
                </div>
                <div>
                    <h5>Participant</h5>
                    <video id="remoteVideo" autoplay playsinline></video>
                </div>
            </div>
            <div class="controls">
                <button id="startCallBtn">Start Call</button>
                <button id="endCallBtn" style="display:none;">End Call</button>
                <button id="retryBtn" style="display:none; background-color: #ff7675;">Retry Connection</button>
            </div>
            <div id="status">Status: Ready to connect</div>
            <div class="debug" id="debugLog"></div>
        </div>
    </div>

    <script>
        const socket = io();
        const room = "{{ meeting_id }}";
        let peerConnection, localStream, remoteStream;
        let isCaller = false;
        let retryCount = 0;
        const maxRetries = 3;

        // Enhanced ICE servers configuration
        const iceServers = {
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                { urls: "stun:stun2.l.google.com:19302" },
                { 
                    urls: "turn:global.turn.twilio.com:3478?transport=udp",
                    username: "YOUR_TWILIO_USERNAME",
                    credential: "YOUR_TWILIO_CREDENTIAL"
                }
            ],
            iceCandidatePoolSize: 10
        };

        // DOM elements
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const startCallBtn = document.getElementById('startCallBtn');
        const endCallBtn = document.getElementById('endCallBtn');
        const retryBtn = document.getElementById('retryBtn');
        const statusDisplay = document.getElementById('status');
        const debugLog = document.getElementById('debugLog');

        // Debug logging
        function log(message, isError = false) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            if (isError) logEntry.style.color = 'red';
            debugLog.prepend(logEntry);
            console.log(message);
        }

        function updateStatus(message) {
            statusDisplay.textContent = `Status: ${message}`;
            log(message);
        }

        // Initialize connection
        async function init() {
            try {
                updateStatus("Initializing connection...");
                startCallBtn.disabled = true;
                
                // Get user media
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        frameRate: { ideal: 30 }
                    },
                    audio: true
                });
                localVideo.srcObject = localStream;
                updateStatus("Local media acquired");

                // Create peer connection
                peerConnection = new RTCPeerConnection(iceServers);
                setupPeerConnectionHandlers();

                // Add local tracks
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });

                // Join room and determine role
                socket.emit('join-room', room);
                isCaller = Math.random() > 0.5; // Simple way to determine caller/callee
                updateStatus(`Joined room as ${isCaller ? 'caller' : 'callee'}`);

                if (isCaller) {
                    await createOffer();
                }

                startCallBtn.style.display = 'none';
                endCallBtn.style.display = 'inline-block';

            } catch (err) {
                log(`Initialization error: ${err}`, true);
                updateStatus("Connection failed");
                retryBtn.style.display = 'inline-block';
                startCallBtn.style.display = 'inline-block';
                startCallBtn.disabled = false;
            }
        }

        // Set up peer connection event handlers
        function setupPeerConnectionHandlers() {
            // ICE candidate handler
            peerConnection.onicecandidate = ({ candidate }) => {
                if (candidate) {
                    log("Sending ICE candidate");
                    socket.emit('ice-candidate', { 
                        room, 
                        candidate,
                        target: isCaller ? 'callee' : 'caller'
                    });
                }
            };

            // Track handler
            peerConnection.ontrack = ({ streams }) => {
                log("Received remote stream");
                remoteVideo.srcObject = streams[0];
                updateStatus("Connected");
            };

            // Connection state monitoring
            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                log(`Connection state: ${state}`);
                
                if (state === 'connected') {
                    updateStatus("Connected");
                    retryCount = 0;
                } else if (state === 'disconnected' || state === 'failed') {
                    updateStatus("Connection lost");
                    if (retryCount < maxRetries) {
                        retryCount++;
                        setTimeout(() => reconnect(), 2000 * retryCount);
                    }
                }
            };

            // ICE connection monitoring
            peerConnection.oniceconnectionstatechange = () => {
                const state = peerConnection.iceConnectionState;
                log(`ICE state: ${state}`);
                
                if (state === 'failed') {
                    log("ICE restarting...");
                    peerConnection.restartIce();
                }
            };
        }

        // Create and send offer
        async function createOffer() {
            try {
                updateStatus("Creating offer...");
                const offer = await peerConnection.createOffer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                await peerConnection.setLocalDescription(offer);
                
                socket.emit('offer', {
                    room,
                    offer,
                    target: 'callee'
                });
                log("Offer sent");
                updateStatus("Offer sent, waiting for answer...");
            } catch (err) {
                log(`Offer error: ${err}`, true);
                updateStatus("Offer failed");
            }
        }

        // Reconnect logic
        async function reconnect() {
            log(`Attempting reconnect (${retryCount}/${maxRetries})`);
            updateStatus(`Reconnecting (${retryCount}/${maxRetries})`);
            
            try {
                if (peerConnection) {
                    peerConnection.close();
                }
                
                await init();
            } catch (err) {
                log(`Reconnect failed: ${err}`, true);
            }
        }

        // Socket event handlers
        socket.on('offer', async ({ offer }) => {
            if (!isCaller) {
                try {
                    log("Received offer");
                    updateStatus("Received offer, creating answer...");
                    
                    if (!peerConnection) {
                        await init();
                    }
                    
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    
                    socket.emit('answer', {
                        room,
                        answer,
                        target: 'caller'
                    });
                    log("Answer sent");
                    updateStatus("Answer sent");
                } catch (err) {
                    log(`Answer error: ${err}`, true);
                    updateStatus("Answer failed");
                }
            }
        });

        socket.on('answer', async ({ answer }) => {
            if (isCaller) {
                try {
                    log("Received answer");
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    updateStatus("Connection established");
                } catch (err) {
                    log(`Set remote description error: ${err}`, true);
                    updateStatus("Connection failed");
                }
            }
        });

        socket.on('ice-candidate', async ({ candidate }) => {
            try {
                log("Received ICE candidate");
                await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            } catch (err) {
                log(`ICE candidate error: ${err}`, true);
            }
        });

        socket.on('user-connected', (userId) => {
            log(`User connected: ${userId}`);
            updateStatus("Peer connected");
        });

        socket.on('user-disconnected', (userId) => {
            log(`User disconnected: ${userId}`);
            updateStatus("Peer disconnected");
        });

        // Button handlers
        startCallBtn.onclick = init;

        endCallBtn.onclick = () => {
            if (peerConnection) {
                peerConnection.close();
                log("Call ended");
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            updateStatus("Call ended");
            startCallBtn.style.display = 'inline-block';
            endCallBtn.style.display = 'none';
            retryBtn.style.display = 'none';
        };

        retryBtn.onclick = () => {
            retryBtn.style.display = 'none';
            reconnect();
        };

        // Error handling
        socket.on("connect_error", (err) => {
            log(`Socket error: ${err}`, true);
            updateStatus("Connection error");
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (peerConnection) peerConnection.close();
            if (localStream) localStream.getTracks().forEach(track => track.stop());
        });
    </script>
</body>
</html>
